# Embedded Development Workspace

AI-assisted embedded development with Claude Code. Custom MCP servers expose build systems, test runners, debug probes, flash programmers, and logic analyzers — so Claude can orchestrate the full firmware workflow from a single conversation.

Embedded development requires constant context-switching between build systems, debug probes, serial monitors, and logic analyzers. By exposing these as MCP tools, Claude can orchestrate the entire workflow — from building firmware to validating boot via RTT to analyzing signal integrity — without the developer leaving the conversation.

## Quick Start

```bash
# Clone with submodules
git clone --recursive <repo-url>
cd embedded-workspace

# Run setup (builds MCP servers, installs dependencies, generates .mcp.json)
./setup.sh
```

## Setup Options

```bash
./setup.sh                              # Install everything (default)
./setup.sh --no-zephyr                  # Skip Zephyr RTOS setup
./setup.sh --no-esp-idf                 # Skip ESP-IDF setup
./setup.sh --no-saleae                  # Skip Saleae Logic setup
./setup.sh --skip-tests                 # Skip test verification
./setup.sh --no-zephyr --no-esp-idf     # Only embedded-probe + saleae-logic
```

The script is idempotent — safe to re-run at any time. It never auto-installs system packages; missing prerequisites are reported with install commands.

## Verify Setup

After running `setup.sh`, validate everything is working:

```bash
./check-dependencies.sh    # PASS/FAIL/WARN for each component
```

| What to check | Expected |
|---------------|----------|
| All 3 Rust binaries built | `claude-mcps/*/target/release/` has executables |
| `.mcp.json` generated | Valid JSON in workspace root with absolute paths |
| Zephyr venv + SDK | `zephyr-apps/.venv/` exists, SDK registered with cmake |
| Commands symlink | `.claude/commands` → `claude-config/commands` |

If any checks fail, re-run `./setup.sh`. See [Troubleshooting](#troubleshooting) for specific fixes.

## MCP Servers

| Server | Language | Purpose |
|--------|----------|---------|
| [embedded-probe](claude-mcps/embedded-probe/PRD.md) | Rust | Debug probes, flash, memory, RTT, breakpoints |
| [saleae-logic](claude-mcps/saleae-logic/PRD.md) | Python | Signal capture, protocol decode, statistical analysis |
| [esp-idf-build](claude-mcps/esp-idf-build/PRD.md) | Rust | ESP32 build, flash, serial monitor |
| [zephyr-build](claude-mcps/zephyr-build/PRD.md) | Rust | Zephyr RTOS build and test (twister) |
| [elf-analysis](claude-mcps/elf-analysis/PRD.md) | Rust | ROM/RAM size analysis and comparison |
| [knowledge-server](claude-mcps/knowledge-server/PRD.md) | Rust | Structured knowledge management with hardware-aware retrieval |

All servers communicate with Claude Code over stdio (JSON-RPC). Registration is automatic via `.mcp.json`, which `setup.sh` generates with absolute paths.

## Prerequisites

| Tool | Required For | Install |
|------|-------------|---------|
| git | Everything | Xcode CLI tools |
| python3 >= 3.10 | Saleae Logic, Zephyr tooling | `brew install python@3.12` |
| Rust (cargo) | embedded-probe, zephyr-build, esp-idf-build | `curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs \| sh` |
| libusb | embedded-probe (macOS) | `brew install libusb` |
| Zephyr SDK | Zephyr compilation | [Getting Started Guide](https://docs.zephyrproject.org/latest/develop/getting_started/index.html) |
| ESP-IDF v5+ | ESP32 builds | [ESP-IDF Setup](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/) |
| Saleae Logic 2 | Signal analysis | [Saleae Download](https://www.saleae.com/downloads/) (enable scripting API in Preferences) |
| Debug probe | Flashing/debugging | J-Link, ST-Link, DAPLink, or CMSIS-DAP |

## Workspace Structure

```
embedded-workspace/
├── .mcp.json                  # MCP server registration (generated by setup.sh)
├── CLAUDE.md                  # Workspace conventions and workflows
├── setup.sh                   # Automated setup script
│
├── claude-config/             # Claude Code skills and configuration (submodule)
├── claude-mcps/               # MCP servers (submodule)
│   ├── embedded-probe/        #   Rust — debug probes, flash, RTT
│   ├── zephyr-build/          #   Rust — build + test (twister)
│   ├── esp-idf-build/         #   Rust — build, flash, monitor
│   ├── elf-analysis/          #   Rust — ROM/RAM size analysis
│   ├── knowledge-server/      #   Rust — structured knowledge management
│   └── saleae-logic/          #   Python — capture + protocol decode
│
├── knowledge/                 # Knowledge store (see Knowledge System below)
│   ├── items/                 #   Structured YAML knowledge items
│   └── boards/                #   Board profile YAML (chip, memory, peripherals)
├── plans/                     # Project plans and tracking (see Plans below)
│
├── zephyr-apps/               # Zephyr applications + west manifest (submodule)
│   └── apps/                  #   Application source code
├── esp-dev-kits/              # ESP-IDF example projects (cloned)
├── test-tools/                # Python testing utilities (submodule)
│
├── zephyr/                    # (west-managed, gitignored)
├── bootloader/                # (west-managed, gitignored)
├── modules/                   # (west-managed, gitignored)
└── tools/                     # (west-managed, gitignored)
```

## Knowledge System

Hard-won learnings from debugging sessions are captured as structured YAML in `knowledge/items/`. The knowledge-server MCP indexes these items with SQLite FTS5 for fast search, and supports hardware-aware retrieval (filter by board, chip, or subsystem).

Knowledge flows through three tiers:

| Tier | Location | When loaded | How updated |
|------|----------|-------------|-------------|
| Critical gotchas | `CLAUDE.md` Key Gotchas section | Every session | `knowledge.regenerate_gotchas()` |
| Topic rules | `.claude/rules/*.md` | Auto-injected when editing matching files | `knowledge.regenerate_rules()` |
| Full corpus | `knowledge/items/*.yml` | On-demand via `/recall` or `knowledge.search()` | `/learn` or `knowledge.capture()` |

Board profiles in `knowledge/boards/` define hardware hierarchy (board → chip → family → arch) with memory maps, peripherals, and known errata.

## Plans

Plans in `plans/` track significant work items through a lifecycle: `Ideation` → `Planned` → `In-Progress` → `Complete`. Required for new MCPs, apps, libraries, or changes touching 5+ files. Completed plans stay in place — status in the file header distinguishes active from done.

## Architecture

```
┌─────────────────────────────────────────────────────────┐
│                    Claude Code (AI)                       │
│  Reads code, writes firmware, orchestrates hardware ops  │
└────────┬──────────┬──────────┬──────────┬───────────────┘
         │          │          │          │
    ┌────▼───┐ ┌───▼────┐ ┌──▼───┐ ┌───▼──────┐
    │zephyr- │ │esp-idf-│ │embed-│ │saleae-   │
    │build   │ │build   │ │ded-  │ │logic     │
    │(Rust)  │ │(Rust)  │ │probe │ │(Python)  │
    └───┬────┘ └───┬────┘ │(Rust)│ └────┬─────┘
        │          │      └──┬──┘      │
        ▼          ▼         │         ▼
    ┌────────┐ ┌────────┐   │    ┌──────────┐
    │west CLI│ │idf.py  │   │    │Logic 2   │
    └────────┘ └────────┘   │    │(gRPC)    │
                            ▼    └──────────┘
                    ┌──────────────┐
                    │  probe-rs    │
                    │  esptool     │
                    │  nrfjprog    │
                    └──────┬──────┘
                           ▼
                    ┌──────────────┐
                    │   Hardware   │
                    │  J-Link      │
                    │  ST-Link     │
                    │  DAPLink     │
                    └──────────────┘
```

All MCP servers communicate over stdio (JSON-RPC). Rust servers use the RMCP SDK; the Python server uses the MCP Python SDK. Each manages its own state and subprocess lifecycle.

### Design Principles

1. **Tools over instructions** — Claude calls tools directly instead of generating shell commands to copy-paste. Eliminates transcription errors and enables multi-step automation.
2. **Subprocess isolation** — Build servers wrap their CLIs as subprocesses rather than linking libraries. Avoids version coupling and uses the same code paths developers use manually.
3. **Background builds** — Long builds (30-120s) run in background with tokio::spawn. Claude can continue the conversation and poll status instead of blocking.
4. **Vendor fallbacks** — probe-rs handles most debug probes natively, but Xtensa ESP32 needs esptool and some Nordic features need nrfjprog. The embedded-probe server provides both paths.
5. **Session-based state** — Debug connections use session IDs, captures use capture IDs. State lives in the MCP server process, not on disk.
6. **Absolute paths everywhere** — All user-supplied paths are resolved to absolute before sending to external tools. Relative paths silently fail when tools have different working directories.

## Getting Started with Claude Code

Open the workspace in Claude Code — MCP servers register automatically from `.mcp.json`.

**First build (no hardware needed):**
1. Run `/start` to bootstrap the session
2. Ask: *"List available apps and boards"*
3. Ask: *"Build crash_debug for qemu_cortex_m3"*
4. Ask: *"Run the unit tests"*

**First hardware session** (with a debug probe connected):
1. Ask: *"List connected probes"*
2. Ask: *"Build and flash blinky to nrf52840dk"*
3. Ask: *"Read RTT output"*

See [CLAUDE.md](CLAUDE.md) for full tool reference, typical workflows, and common boards.

## Testing

All tests run without hardware connected:

```bash
# Run all tests (done automatically by setup.sh unless --skip-tests)
cd claude-mcps/embedded-probe && cargo test
cd claude-mcps/zephyr-build && cargo test
cd claude-mcps/esp-idf-build && cargo test
cd claude-mcps/saleae-logic && .venv/bin/pytest tests/test_analysis.py tests/test_server_startup.py
```

## Troubleshooting

| Problem | Solution |
|---------|----------|
| `west: command not found` | Activate venv: `source zephyr-apps/.venv/bin/activate` |
| `cargo build` fails on macOS | Install libusb: `brew install libusb` |
| ESP-IDF not detected | Set `IDF_PATH` or install to `~/esp/esp-idf` |
| Logic 2 connection refused | Start Logic 2 app, enable scripting API in Preferences |
| Twister fails with toolchain error | Run SDK's `setup.sh` to register with cmake, or set `ZEPHYR_SDK_INSTALL_DIR` |
| Wrong paths in `.mcp.json` | Re-run `./setup.sh` (regenerates with current absolute paths) |
| Submodule directories empty | Run `git submodule update --init --recursive` |

## Documentation

- [CLAUDE.md](CLAUDE.md) — MCP tool reference, typical workflows, and conventions for Claude Code
- [claude-mcps/embedded-probe/PRD.md](claude-mcps/embedded-probe/PRD.md) — Debug probe server
- [claude-mcps/saleae-logic/PRD.md](claude-mcps/saleae-logic/PRD.md) — Logic analyzer server
- [claude-mcps/esp-idf-build/PRD.md](claude-mcps/esp-idf-build/PRD.md) — ESP-IDF build server
- [claude-mcps/zephyr-build/PRD.md](claude-mcps/zephyr-build/PRD.md) — Zephyr build server
- [claude-mcps/elf-analysis/PRD.md](claude-mcps/elf-analysis/PRD.md) — ELF size analysis server
- [claude-mcps/knowledge-server/PRD.md](claude-mcps/knowledge-server/PRD.md) — Knowledge management server
