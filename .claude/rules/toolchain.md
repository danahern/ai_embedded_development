---
paths: ["**/*provision_tool*.py", "**/.github/workflows/*.yml", "**/Dockerfile", "**/Dockerfile.alif-e7", "**/bblayers.conf", "**/ble/*.py", "**/build-alif-e7/**", "**/build-alif-e7/conf/bblayers.conf", "**/build_tools.rs", "**/docker/*", "**/downloads/git2/**", "**/freertos/thread.c", "**/freertos/workqueue.c", "**/linux/apps/*/Makefile", "**/local.conf", "**/meta-alif-ensemble/**", "**/openocd*.rs", "**/openocd_client.rs", "**/posix/*.c", "**/posix/*.h", "**/pyproject.toml", "**/types.rs", "claude-mcps/linux-build/src/*.rs", "firmware/linux/**", "yocto-build/build-alif-e7/**"]
---
# Toolchain Learnings

- **Alif E7 Yocto: BSP source variables must be set manually with poky distro** — When using `DISTRO = "poky"` (not `apss-tiny`), the Alif BSP source variables are not auto-configured. These must be set in `local.conf`:
- **ESP32 FreeRTOS StackType_t is uint8_t — stack sizes in bytes not words** — On Xtensa ESP32, `StackType_t` is `uint8_t` (not `uint32_t` like ARM Cortex-M). This means `xTaskCreate()` stack_depth parameter is in BYTES, not words. A value of 2048 gives only 2KB of stack, not 8KB.
- **meta-alif requires meta-filesystems layer** — The meta-alif Yocto BSP layer depends on meta-filesystems (from meta-openembedded). This is listed in meta-alif/README as a required layer. The STM32MP1 Yocto build does not need meta-filesystems, so it must be explicitly added to bblayers.conf for E7 builds. meta-filesystems is already available in our meta-openembedded clone.
- **Alif E7 uses devkit-e8 machine config in scarthgap (not devkit-e7)** — In the scarthgap branch of meta-alif-ensemble, devkit-e7.conf was renamed to devkit-e7.conf.orig and superseded by devkit-e8.conf. The E8 config still targets E7 hardware (TF-A_PLATFORM = "devkit_e7") but has updated memory layout, SMP=1 default (dual A32), and reorganized HyperRAM/OSPI logic. Always use MACHINE = "devkit-e8" for E7 DevKit builds on scarthgap.
- **linux-build MCP overrides CMD with sleep infinity** — The linux-build MCP's `start_container` runs `bash -c "mkdir -p /artifacts && sleep infinity"` as the container command, overriding any Dockerfile CMD. If the image runs as a non-root user (e.g., Buildroot's `builder` user), `mkdir -p /artifacts` fails because `/artifacts` is at the filesystem root. Fix: pre-create `/artifacts` in the Dockerfile with correct ownership before switching to the non-root user:
- **espressif/idf Docker container needs manual export.sh in GitHub Actions** — The `espressif/idf:v5.5.2` Docker image sets `IDF_PATH` but relies on its entrypoint to source `export.sh` and add `idf.py` to PATH. GitHub Actions overrides the container entrypoint when using `container:`, so `idf.py` is not found (exit code 127).
- **Tokio ChildStdout cannot pipe into process stdin — use spawn_blocking** — Tokio's `tokio::process::ChildStdout` does not implement `Into<std::process::Stdio>`, so you can't pipe a Tokio child's stdout directly into another Tokio Command's stdin. The `into_std()` method also doesn't exist on older Tokio versions.
- **macOS POSIX gaps: 3 missing APIs require workarounds** — macOS is POSIX-compliant but lacks three commonly-assumed APIs:
- **Per-board build directories in zephyr-build MCP** — Build directories changed from `apps/<name>/build/` to `apps/<name>/build/<board_sanitized>/` where `/` in board names becomes `_` (e.g., `nrf7002dk/nrf5340/cpuapp` → `nrf7002dk_nrf5340_cpuapp`). This prevents building for one board from wiping another board's artifacts. `clean(app)` removes all board builds; `clean(app, board)` removes just one. `list_apps()` now returns `built_boards` array instead of single `board` field.
- **OpenOCD TCL protocol uses 0x1a (SUB) as message terminator** — OpenOCD's TCL interface (default port 6666) uses ASCII SUB character (0x1a / Ctrl-Z) as the message terminator, not newline. Both commands and responses are terminated with this byte.
- **Yocto bitbake fetch timeout: pre-clone large git repos into downloads/git2/** — Bitbake's fetcher can timeout when cloning large git repos (e.g., Linux kernel). The fetch command runs with restricted PATH and environment, so even though `git clone` works from the shell, bitbake's internal timeout may kill it.
- **bleak macOS: BLEDevice UUID expires between scans — use find_device helper** — On macOS, CoreBluetooth assigns UUIDs that can expire between BLE scan sessions. Passing a stale UUID string to `BleakClient(address)` raises `BleakDeviceNotFoundError`. Fix: always do a fresh `BleakScanner.discover()` and pass the `BLEDevice` object to `BleakClient(device)`. Use `return_adv=True` for advertisement data (RSSI). The `BLEDevice.rssi` attribute was removed in newer bleak versions.
- **Alif E7 Yocto: meta-filesystems requires meta-networking layer** — `meta-alif` requires `meta-filesystems` from meta-openembedded. `meta-filesystems` depends on `meta-networking`, which must also be included in `bblayers.conf`. The STM32MP1 build didn't need it because `meta-st-stm32mp` doesn't depend on `meta-filesystems`.
- **Buildroot stm32mp157c_dk2_defconfig produces complete SD card image** — Upstream Buildroot (not ST's fork) has a built-in `stm32mp157c_dk2_defconfig` that produces a complete bootable SD card image. Build deps: build-essential, bison, flex, libssl-dev, libncurses-dev, unzip, wget, curl, git, bc, cpio, rsync, python3, file, locales. Must build as non-root user. First build ~45 min on 10-core. Output images in `output/images/`: sdcard.img (~123MB, GPT with TF-A + U-Boot FIP + rootfs.ext4), zImage, stm32mp157c-dk2.dtb, tf-a-stm32mp157c-dk2.stm32, fip.bin. Flash with `dd if=sdcard.img of=/dev/sdX bs=4M`. Login: root (no password).
- **Cortex-A32 vs A7 cross-compilation flags** — STM32MP1 (Cortex-A7): -mcpu=cortex-a7 -mfpu=neon-vfpv4 -mfloat-abi=hard, uses Buildroot toolchain (arm-none-linux-gnueabihf-gcc). Alif E7 (Cortex-A32): -mcpu=cortex-a32 -mfpu=neon -mfloat-abi=hard, uses system cross-compiler (arm-linux-gnueabihf-gcc from crossbuild-essential-armhf). The Alif E7 Docker image is much smaller since it doesn't need a full Buildroot build — just the distro cross-compiler package.
- **Python MCP pyproject.toml must use setuptools.build_meta** — When creating Python MCP servers with setuptools, the build-backend must be `setuptools.build_meta`, not `setuptools.backends._legacy:_Backend`. The legacy backend causes installation failures. Follow the saleae-logic pattern: `[build-system]\nrequires = ["setuptools>=68.0"]\nbuild-backend = "setuptools.build_meta"`. Add dev dependencies in `[project.optional-dependencies]` for pytest.
