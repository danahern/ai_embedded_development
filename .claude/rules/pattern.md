---
paths: ["**/*_cred*.c", "**/*cred*.c", "**/*settings*.c", "**/*wifi*.c", "**/eai_osal/**", "**/settings*.c", "**/wifi_prov*.c", "**/workqueue*", "*/tools/build_tools.rs", "*/tools/templates.rs", "addons/*.yml", "tasks/prd.json", "tasks/progress.md"]
---
# Pattern Learnings

- **OSAL work queues must be static — thread outlives stack frame** — `eai_osal_workqueue_create()` (and Zephyr's `k_work_queue_start()`) spawns a persistent thread. If the `eai_osal_workqueue_t` is stack-allocated in a function, the thread continues running after the function returns, referencing freed stack memory. This causes hard faults (typically "ESF could not be retrieved" / fault during interrupt handling).
- **settings_subsys_init() required before settings_save_one()** — Zephyr's Settings subsystem requires `settings_subsys_init()` before any `settings_save_one()` or `settings_load_subtree()` calls. Without it, save returns -2 (ENOENT). The init function registers the NVS backend and creates the partition. Call it early in the module init, before any credential load/save operations.
- **Zephyr Settings h_set handler must return 0 on success** — The Settings subsystem `h_set` handler must return 0 on success. The `read_cb()` function returns positive byte count on success, but returning that directly from `h_set` causes "set-value failure" warnings. Fix: `int rc = read_cb(...); return rc < 0 ? rc : 0;`
- **WiFi connect must be non-blocking from BLE context** — On nRF7002, `net_mgmt(NET_REQUEST_WIFI_CONNECT)` returns immediately but the WPA supplicant may send transient failure events before succeeding. Never use a blocking semaphore to wait for the connect result — instead, handle `NET_EVENT_WIFI_CONNECT_RESULT` asynchronously. The initial "Network interface is not configured" error (status=1) from wpa_supp is transient; the connection succeeds ~15s later. Also call `net_dhcpv4_start()` in the connect success handler, not inline after the request.
- **Composable addons: YAML-based code generation for create_app** — The `create_app` tool supports composable addons via YAML files in `firmware/addons/<name>.yml`. Each addon has optional sections: `kconfig`, `includes`, `globals`, `init`. The `libraries` parameter resolves names as either a library (`lib/<name>/manifest.yml` → overlay injection) or addon (`addons/<name>.yml` → code generation). Libraries are checked first.
- **Ralph Loop should exit after each user story, not batch** — When using the Ralph Loop plugin with a PRD containing multiple user stories, each iteration should:
- **Ralph Loop needs introspection/progress file before exit** — Before exiting a Ralph Loop iteration, the agent should write a progress file (e.g., `tasks/progress.md` or update prd.json notes) that captures:
