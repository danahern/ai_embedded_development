---
paths: ["**/*_cred*.c", "**/*cred*.c", "**/*settings*.c", "**/*wifi*.c", "**/eai_osal/**", "**/settings*.c", "**/wifi_prov*.c", "**/workqueue*", "*/tools/build_tools.rs", "*/tools/templates.rs", "addons/*.yml", "firmware/lib/*/src/*.c", "tasks/prd.json", "tasks/progress.md"]
---
# Pattern Learnings

- **OSAL work queues must be static — thread outlives stack frame** — `eai_osal_workqueue_create()` (and Zephyr's `k_work_queue_start()`) spawns a persistent thread. If the `eai_osal_workqueue_t` is stack-allocated in a function, the thread continues running after the function returns, referencing freed stack memory. This causes hard faults (typically "ESF could not be retrieved" / fault during interrupt handling).
- **Zephyr Settings h_set handler must return 0 on success** — The Settings subsystem `h_set` handler must return 0 on success. The `read_cb()` function returns positive byte count on success, but returning that directly from `h_set` causes "set-value failure" warnings. Fix: `int rc = read_cb(...); return rc < 0 ? rc : 0;`
- **Portable C code must explicitly include errno.h for EINVAL/ENOTCONN** — When writing portable C code that uses errno constants (EINVAL, ENOTCONN, ENOENT, etc.), always include `<errno.h>` explicitly. On Zephyr, errno.h is pulled in transitively by many headers (eai_log.h, kernel.h, etc.), so code compiles without it. On ESP-IDF (newlib), these headers do NOT pull in errno.h transitively, causing "undeclared" errors. This was hit in wifi_prov_ble.c and wifi_prov_wifi.c during the wifi_prov unification — both used `-EINVAL` and `-ENOTCONN` without including errno.h.
- **ESP-IDF credential API must return proper errno values for cross-platform compatibility** — When implementing platform-specific backends for shared library APIs, use proper POSIX errno values (not generic `-1`). The ESP-IDF credential implementation (`wifi_prov_cred_esp.c`) initially returned `-1` for all errors, but the Zephyr version and unit tests expect:
- **WiFi connect must be non-blocking from BLE context** — On nRF7002, `net_mgmt(NET_REQUEST_WIFI_CONNECT)` returns immediately but the WPA supplicant may send transient failure events before succeeding. Never use a blocking semaphore to wait for the connect result — instead, handle `NET_EVENT_WIFI_CONNECT_RESULT` asynchronously. The initial "Network interface is not configured" error (status=1) from wpa_supp is transient; the connection succeeds ~15s later. Also call `net_dhcpv4_start()` in the connect success handler, not inline after the request.
- **Ralph Loop should exit after each user story, not batch** — When using the Ralph Loop plugin with a PRD containing multiple user stories, each iteration should:
- **Composable addons: YAML-based code generation for create_app** — The `create_app` tool supports composable addons via YAML files in `firmware/addons/<name>.yml`. Each addon has optional sections: `kconfig`, `includes`, `globals`, `init`. The `libraries` parameter resolves names as either a library (`lib/<name>/manifest.yml` → overlay injection) or addon (`addons/<name>.yml` → code generation). Libraries are checked first.
- **settings_subsys_init() required before settings_save_one()** — Zephyr's Settings subsystem requires `settings_subsys_init()` before any `settings_save_one()` or `settings_load_subtree()` calls. Without it, save returns -2 (ENOENT). The init function registers the NVS backend and creates the partition. Call it early in the module init, before any credential load/save operations.
- **Ralph Loop needs introspection/progress file before exit** — Before exiting a Ralph Loop iteration, the agent should write a progress file (e.g., `tasks/progress.md` or update prd.json notes) that captures:
